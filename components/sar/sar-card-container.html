<link href="../polymer/polymer.html" rel="import">

<link href="../firebase-element/firebase-collection.html" rel="import">
<link href="../iron-flex-layout/iron-flex-layout.html" rel="import">
<link href="../neon-animation/neon-shared-element-animatable-behavior.html" rel="import">
<link href="../paper-radio-button/paper-radio-button.html" rel="import">
<link href="../paper-radio-group/paper-radio-group.html" rel="import">
<link href="../paper-scroll-header-panel/paper-scroll-header-panel.html" rel="import">
<link href="../paper-slider/paper-slider.html" rel="import">
<link href="../paper-toggle-button/paper-toggle-button.html" rel="import">

<link href="../sar/sar-card.html" rel="import">


<dom-module id="sar-card-container">
  <style is="custom-style">
    :host {
      display: flex;
      flex-direction: row;
      flex-wrap: wrap;
      justify-content: center;
      align-items: stretch;
      height: 100%;
      @apply(--layout);
      @apply(--layout-fit);
    }
    #header {
      color: silver;
      font-size: 54px;
      font-family: 'PT Sans Narrow', 'Open Sans', Helvetica, Arial, sans-serif;
      @apply(--layout-self-end);
    }
    #paper-scroll-header-panel {
      @apply(--layout-fit);
    }
    .paper-header {
      padding: 0 6%;
      white-space: nowrap;
      height: 168px;
      @apply(--layout);
    }
    .content {
      padding: 0 6%;
      @apply(--layout-vertical);
    }
    #filters {
      margin: 30px 0;
      @apply(--layout-wrap);
    }
    .cards {
      @apply(--layout-center-justified);
      @apply(--layout-horizontal);
      @apply(--layout-wrap);
    }
    .horizontal {
      @apply(--layout-horizontal);
    }
    .vertical {
      @apply(--layout-vertical);
    }
    .spacer {
      width: 28px;
    }
    paper-radio-group {
      margin-top: -2px;
    }
    paper-radio-button {
      padding: 0 10px 5px;
    }
    paper-radio-button::shadow #radioLabel {
      margin-left: 3px;
    }
    paper-toggle-button {
      padding: 0 2px 9px 10px;
    }
    paper-toggle-button::shadow #ink {
      top: -2px;
      left: -2px;
      height: 24px;
      width: 24px;
    }
    paper-toggle-button {
      transform: scale(0.72);
      --paper-toggle-button-checked-bar-color: var(--default-primary-color);
      --paper-toggle-button-checked-button-color: var(--default-primary-color);
      --paper-toggle-button-checked-ink-color: var(--default-primary-color);
    }
    paper-slider {
      --paper-slider-active-color: var(--default-primary-color);
      --paper-slider-knob-color: var(--default-primary-color);
    }
    .sliderContainer, .sliderContainer paper-slider {
      width: 200px;
    }
    #minRatingSlider {
      margin-top: -7px;
    }
    #minRatingText {
      text-align: right;
      margin-right: 12px;
      margin-top: -5px;
    }
    #titleSearch {
      margin-top: -28px;
      --paper-input-container-input: {
        font-family: inherit;
        font-size: inherit;
        font-weight: inherit;
        line-height: inherit;
        color: inherit;
      };
      --paper-input-container-label: {
        font-family: inherit;
        font-size: inherit;
        font-weight: inherit;
        line-height: inherit;
      };
    }
  </style>
  <template>
    <firebase-collection
        location="https://sexy-anime-reviews.firebaseio.com/reviews"
        data="{{reviews}}"></firebase-collection>
    <paper-scroll-header-panel id="paper-scroll-header-panel" noReveal no-reveal>
      <div class="paper-header">
        <div id="header">Spoiler Free Anime Reviews</div>
      </div>
      <div class="content">
        <div class="horizontal" id="filters">
          <div class="horizontal">
            <div>Order by</div>
            <paper-radio-group class="vertical" selected="{{orderBy}}">
              <paper-radio-button name="title">Title</paper-radio-button>
              <paper-radio-button name="rating">Rating</paper-radio-button>
            </paper-radio-group>
          </div>
          <div class="spacer"></div>
          <div class="horizontal">
            <div>Show</div>
            <div class="vertical">
              <div class="horizontal">
                <paper-toggle-button checked="{{showDub}}"></paper-toggle-button>
                <div>Dubs</div>
              </div>
              <div class="horizontal">
                <paper-toggle-button checked="{{showSub}}"></paper-toggle-button>
                <div>Subs</div>
              </div>
            </div>
          </div>
          <div class="spacer"></div>
          <div class="vertical">
            <div class="horizontal">
              <div>Min rating</div>
              <div class="vertical sliderContainer">
                <paper-slider id="minRatingSlider" value="{{minRating}}" min="1" max="10" snaps on-value-change="_minRatingChanged"></paper-slider>
                <div id="minRatingText">[[minRatingText]]</div>
              </div>
            </div>
          </div>
          <div class="spacer"></div>
          <paper-input id="titleSearch" label="Search by title" value="{{searchString}}"></paper-input>
        </div>
        <div class="cards">
          <template is="dom-repeat" items="[[reviews]]" sort="[[sortFunction]]" filter="[[filterFunction]]">
            <sar-card review="[[item]]" on-card-click="_onCardClick"></sar-card>
          </template>
        </div>
      </div>
    </paper-scroll-header-panel>
  </template>
</dom-module>

<script>
</script>
<script>
  var RATING_VALUES = {
    'epic': 10,
    'superb': 9,
    'great': 8,
    'good': 7,
    'fair': 6,
    'meh': 5,
    'poor': 4,
    'bad': 3,
    'terrible': 2,
    'abysmal': 1
  };

  Polymer({
    is: 'sar-card-container',
    behaviors: [
      Polymer.NeonSharedElementAnimatableBehavior
    ],
    listeners: {
      'immediate-value-change': '_immediateMinRatingChanged'
    },
    properties: {
      reviews: Array,
      sortFunction: Function,
      filterFunction: Function,
      orderBy: {
        type: String,
        value: 'title',
        observer: '_orderByChanged'
      },
      showDub: {
        type: Boolean,
        value: true,
        observer: '_updateFilterFunction'
      },
      showSub: {
        type: Boolean,
        value: true,
        observer: '_updateFilterFunction'
      },
      searchString: {
        type: String,
        observer: '_updateFilterFunction'
      },
      minRating: {
        type: Number,
        value: 0,
        observer: '_updateFilterFunction'
      },
      minRatingText: {
        type: String,
        value: 'abysmal'
      },
      ratingValuesInverted: {
        type: Array,
        readOnly: true,
        value: function() { return ['n/a', 'abysmal', 'terrible', 'bad', 'poor', 'meh', 'fair', 'good', 'great', 'superb', 'epic']; }
      },
      animationConfig: {
        value: function() {
          // var cards = Polymer.dom(this.root).querySelectorAll('.card');
          // var cardsArray = Array.prototype.slice.call(cards);
          return {
            'entry': [{
              name: 'hero-animation',
              id: 'hero',
              toPage: this
            }, {
              name: 'cascaded-animation',
              // nodes: cardsArray,
              animation: 'transform-animation'
            }, {
              name: 'fade-in-animation',
              timing: {
                delay: 500,
                duration: 100
              }
            }, {
              name: 'hero-animation',
              id: 'hero-header',
              toPage: this
            }, {
              name: 'fade-in-animation',
              node: this.$.filters
            }],
            'exit': [{
              name: 'hero-animation',
              id: 'hero',
              fromPage: this,
              timing: {
                delay: 100
              }
            }, {
              name: 'cascaded-animation',
              animation: 'transform-animation',
              nodedelay: 50
            }, {
              name: 'fade-out-animation',
              timing: {
                duration: 100
              }
            }, {
              name: 'hero-animation',
              id: 'hero-header',
              fromPage: this
            }, {
              name: 'fade-out-animation',
              node: this.$.filters
            }]
          };
        }
      }
    },
    _onCardClick: function(event) {
      var target = Polymer.dom(event).localTarget;
      this.sharedElements = {
        'hero': event.detail.cover,
        'hero-header': this.$.header
      };
      var nodesToExit = [];
      var cards = Polymer.dom(this.root).querySelectorAll('sar-card');
      var farthestDistance = 0;  // card top relative to viewport bottom edge
      var viewportHeight = window.document.documentElement.clientHeight;
      for (var node, idx = 0; node = cards[idx]; idx++) {
        if (node !== target && this._isNodeInViewport(node)) {
          nodesToExit.push(node);
          // distance of node's top to viewport bottom edge
          var d = viewportHeight - node.getBoundingClientRect().top;
          farthestDistance = d > farthestDistance ? d : farthestDistance;
        }
      }
      this.animationConfig['entry'][1].transformFrom = 'translateY(' + farthestDistance + 'px)';
      this.animationConfig['exit'][1].transformTo = 'translateY(' + farthestDistance + 'px)';
      this.animationConfig['entry'][1].nodes = nodesToExit;
      this.animationConfig['exit'][1].nodes = nodesToExit;
      this.animationConfig['entry'][2].node = event.detail.title;
      this.animationConfig['exit'][2].node = event.detail.title;

      this.fire('card-selected', {review: event.detail.review});
    },
    _isNodeInViewport: function(node) {
      return node.getBoundingClientRect().bottom > 0 &&
          node.getBoundingClientRect().top < window.document.documentElement.clientHeight;
    },
    _orderByChanged: function(newOrderBy) {
      this.sortFunction = this._sortFunctions[newOrderBy];
    },
    _sortFunctions: {
      'title': function(a, b) {
        return a.title.localeCompare(b.title);
      },
      'rating': function(a, b) {
        return RATING_VALUES[b.rating] - RATING_VALUES[a.rating];
      }
    },
    _updateFilterFunction: function() {
      var showDub = this.showDub, showSub = this.showSub;
      var minRating = this.minRating;
      var searchString = this.searchString;
      if (showDub === undefined || showSub === undefined || minRating === undefined || searchString === undefined) {
        return;
      }
      this.filterFunction = function(x) {
        var filtered =
            (!showDub && x.viewMethod === 'dub') ||
            (!showSub && x.viewMethod === 'sub') ||
            (minRating > RATING_VALUES[x.rating]) ||
            (!!searchString && x.title.toLowerCase().indexOf(searchString.toLowerCase()) < 0);
        return !filtered;
      };
    },
    _immediateMinRatingChanged: function() {
      this.minRatingText = this.ratingValuesInverted[this.$.minRatingSlider.immediateValue];
    },
    _minRatingChanged: function() {
      this.minRatingText = this.ratingValuesInverted[this.minRating];
    }
  });
</script>